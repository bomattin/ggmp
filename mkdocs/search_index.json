{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction to the GGMP\n\n\nThe Generic Gameserver Messaging Protocol, or GGMP, is a messaging protocol that sits atop UDP. The protocol is designed\nfrom the ground up to send Messages between game servers and clients. Messages are designed to contain easily decodable\ninformation about updates to game state.\n\n\nGoals for the proposed protocol are:\n\n\n\n\nLightweight: Exactly as much data as needed and no more.\n\n\nSelf-contained: Transmit as much information about an Action in one Message as possible\n\n\nEfficient: Small packet size, in pure bytes for ease of server and client-side processing.\n\n\nResilient: A lost or malformed packet will be handled by the server, and is not breaking.\n\n\nFlexible: Usable for anything from a simple command-line game to a full-blown RTS.\n\n\n\n\nNon-goals are:\n\n\n\n\nData integrity: Following a common design pattern among games, dropped packets are not game breaking.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction-to-the-ggmp", 
            "text": "The Generic Gameserver Messaging Protocol, or GGMP, is a messaging protocol that sits atop UDP. The protocol is designed\nfrom the ground up to send Messages between game servers and clients. Messages are designed to contain easily decodable\ninformation about updates to game state.  Goals for the proposed protocol are:   Lightweight: Exactly as much data as needed and no more.  Self-contained: Transmit as much information about an Action in one Message as possible  Efficient: Small packet size, in pure bytes for ease of server and client-side processing.  Resilient: A lost or malformed packet will be handled by the server, and is not breaking.  Flexible: Usable for anything from a simple command-line game to a full-blown RTS.   Non-goals are:   Data integrity: Following a common design pattern among games, dropped packets are not game breaking.", 
            "title": "Introduction to the GGMP"
        }, 
        {
            "location": "/components/", 
            "text": "GGMP Message Components\n\n\nGGMP Messages are comprised of \nComponents\n, which describe the Message format itself, as well as Client ID, Actors and\n Actions, and so on. Not every Component is included in every Message; the Header dictates the \nMessage Type\n, which \nfurther dictates the Components and structure of the Message.\n\n\nHEAD: Header\n\n\n\n\nSize: 1 byte\n\n\nAcceptable Values: 0x00 - 0xFF\n\n\n\n\nThe Header dictates the Message Type. The following Message Types are currently available in GGMP. For information on \ntheir structure, see \nMessage Types\n\n\n\n\n\n\n\n\nHeader Value\n\n\nType\n\n\nDescription\n\n\nSize (bytes)\n\n\n\n\n\n\n\n\n\n\n0x00\n\n\nAction\n\n\nLong-form Action with Conditions, Message IDs\n\n\n20\n\n\n\n\n\n\n0x01\n\n\nActionAck\n\n\nLong-form Action as above, but require ACK\n\n\n20\n\n\n\n\n\n\n0x02\n\n\nActionShort\n\n\nLightweight Action with reduced value ranges\n\n\n8\n\n\n\n\n\n\n0x04\n\n\nActionExtended\n\n\nAction with additional data contained in a following message\n\n\n20\n\n\n\n\n\n\n0x0E\n\n\nData\n\n\nData corresponding to a previous message\n\n\n?\n\n\n\n\n\n\n0x12\n\n\nDataEnd\n\n\nFinal Data corresponding to a previous message\n\n\n?\n\n\n\n\n\n\n0xFE\n\n\nClient Assign\n\n\nUsed by server to assign a Client ID to a connected Client\n\n\n?\n\n\n\n\n\n\n0xFF\n\n\nAck\n\n\nAcknowledge a previous message which has requested it\n\n\n?\n\n\n\n\n\n\n\n\nAn important note: Any even-numbered Message Type in the range 0x00 to 0xEE can require an ACK by increasing the value \nof the Header by 0x01. In the table above, this property is explicitly written for the Action message type, however this\nproperty is implemented for all Message Types in the above range, and is simply implied in much of this documentation.\n\n\nCL: Client ID\n\n\n\n\nSize: 3 bytes \n\n\nAcceptable Values: 0x000001 - 0xFFFFFF for Clients, 0x00 for Server\n\n\n\n\nThe Client ID is a value assigned to a Client by the Game Server. It is useful for tracking origin of a Message as it is\nprocessed by the Game Server. Additionally, it provides a way, if desired, to delineate Actors based on Client. A game \ncould choose to have all actors 'owned' by a particular client, providing a number of benefits, not the least of which \nis an additional layer of security against message spoofing.\n\n\nThe Client ID 0x00 is reserved for the Game Server itself. Further Client IDs should begin at 0x01 and increment by 0x01\nfor each new client assigned.\n\n\nMID: Message ID\n\n\n\n\nSize: 4 bytes\n\n\nAcceptable Values: 0x00000000 - 0xFFFFFFFFF\n\n\nOptional\n\n\n\n\nThe Message ID is an optional Component that can assist with certain features in advanced GGMP implementations. For \nexample, any game requiring the use of ACKs must implement Message IDs. Additionally, Message IDs can be used to estimate\npacket loss, ensure correct ordering of packets, etc.\n\n\nMessage IDs should be unique per client per message. That is to say: no one Client should send multiple Messages with \nthe same ID. However, Messages from \ndifferent\n clients can share IDs, and in fact this is expected.\n\n\nEach client should begin counting their Messages at 0x00000000 and increment them by 0x01 with every message sent.\n\n\nIf a game does not choose to implement Message IDs, the byte ranges designated for Message IDs should be cleared to \n 0x00000000.\n\n\nAR: Actor\n\n\n\n\nSize: 4 bytes\n\n\nAcceptable Values: 0x00000000 - 0xFFFFFFFF\n\n\n\n\nThe Actor is any game entity which takes an Action. The assignment, interpretation, and implementation of these actors \nis left entirely to the programmer. Actors can correspond to individual players, units controlled by players, the game \nstate itself, etc.\n\n\nIt is recommended, though not required, that Actor 0x00 be reserved for the keeper of the game state.\n\n\nAN: Action\n\n\n\n\nSize: 4 bytes\n\n\nAcceptable Values: 0x00000000 - 0xFFFFFFFF\n\n\n\n\nAn Action is a game event taken by an Actor. Like the definition of an Actor, Actions are left intentionally vague. They\ncan communicate game state (though this is discouraged) or game actions. \n\n\nAC1, AC2: Action Condition 1 and 2\n\n\n\n\nSize: 4 bytes each\n\n\nAcceptable Values: 0x00000000 - 0xFFFFFFFF\n\n\nOptional\n\n\n\n\nAction Conditions act as parameters for Actions. They are used to attach data an Action. Their use is optional. If an \nAction does not require the use of Conditions, the byte ranges for those conditions should be cleared to 0x00.\n\n\nIf the data associated with an Action would exceed 8 bytes, use an \nActionExt\n Message, which sends arbitrary data in\na following \nData\n or \nDataEnd\n Message. \n\n\nDAT : Action Data\n\n\n\n\nSize: User-defined\n\n\nAcceptable Values: User-defined\n\n\n\n\nAction Data makes up the primary content of a \nData\n Message. Its purpose is to communicate data which is too large to\nfit in a standard \nAction\n Message. \n\n\nSIZ: Data Size\n\n\n\n\nSize: 1 byte\n\n\nAcceptable Values: 0x00 - 0xFF\n\n\n\n\nData Size specifies the length, in bytes, of Action Data attached to a \nData\n or \nDataEnd\n Message.\n\n\nPMSG: Parent Message\n\n\n\n\nSize: 4 bytes\n\n\nAcceptable Values: 0x00000000 - 0xFFFFFFFF\n\n\n\n\nParent Message is used by \nData\n/\nDataEnd\n or \nAck\n Messages to express the Message ID with which they are associated. A \n\nData\n/\nDataEnd\n Message must additionally have a Message ID of its own.", 
            "title": "Components"
        }, 
        {
            "location": "/components/#ggmp-message-components", 
            "text": "GGMP Messages are comprised of  Components , which describe the Message format itself, as well as Client ID, Actors and\n Actions, and so on. Not every Component is included in every Message; the Header dictates the  Message Type , which \nfurther dictates the Components and structure of the Message.", 
            "title": "GGMP Message Components"
        }, 
        {
            "location": "/components/#head-header", 
            "text": "Size: 1 byte  Acceptable Values: 0x00 - 0xFF   The Header dictates the Message Type. The following Message Types are currently available in GGMP. For information on \ntheir structure, see  Message Types     Header Value  Type  Description  Size (bytes)      0x00  Action  Long-form Action with Conditions, Message IDs  20    0x01  ActionAck  Long-form Action as above, but require ACK  20    0x02  ActionShort  Lightweight Action with reduced value ranges  8    0x04  ActionExtended  Action with additional data contained in a following message  20    0x0E  Data  Data corresponding to a previous message  ?    0x12  DataEnd  Final Data corresponding to a previous message  ?    0xFE  Client Assign  Used by server to assign a Client ID to a connected Client  ?    0xFF  Ack  Acknowledge a previous message which has requested it  ?     An important note: Any even-numbered Message Type in the range 0x00 to 0xEE can require an ACK by increasing the value \nof the Header by 0x01. In the table above, this property is explicitly written for the Action message type, however this\nproperty is implemented for all Message Types in the above range, and is simply implied in much of this documentation.", 
            "title": "HEAD: Header"
        }, 
        {
            "location": "/components/#cl-client-id", 
            "text": "Size: 3 bytes   Acceptable Values: 0x000001 - 0xFFFFFF for Clients, 0x00 for Server   The Client ID is a value assigned to a Client by the Game Server. It is useful for tracking origin of a Message as it is\nprocessed by the Game Server. Additionally, it provides a way, if desired, to delineate Actors based on Client. A game \ncould choose to have all actors 'owned' by a particular client, providing a number of benefits, not the least of which \nis an additional layer of security against message spoofing.  The Client ID 0x00 is reserved for the Game Server itself. Further Client IDs should begin at 0x01 and increment by 0x01\nfor each new client assigned.", 
            "title": "CL: Client ID"
        }, 
        {
            "location": "/components/#mid-message-id", 
            "text": "Size: 4 bytes  Acceptable Values: 0x00000000 - 0xFFFFFFFFF  Optional   The Message ID is an optional Component that can assist with certain features in advanced GGMP implementations. For \nexample, any game requiring the use of ACKs must implement Message IDs. Additionally, Message IDs can be used to estimate\npacket loss, ensure correct ordering of packets, etc.  Message IDs should be unique per client per message. That is to say: no one Client should send multiple Messages with \nthe same ID. However, Messages from  different  clients can share IDs, and in fact this is expected.  Each client should begin counting their Messages at 0x00000000 and increment them by 0x01 with every message sent.  If a game does not choose to implement Message IDs, the byte ranges designated for Message IDs should be cleared to \n 0x00000000.", 
            "title": "MID: Message ID"
        }, 
        {
            "location": "/components/#ar-actor", 
            "text": "Size: 4 bytes  Acceptable Values: 0x00000000 - 0xFFFFFFFF   The Actor is any game entity which takes an Action. The assignment, interpretation, and implementation of these actors \nis left entirely to the programmer. Actors can correspond to individual players, units controlled by players, the game \nstate itself, etc.  It is recommended, though not required, that Actor 0x00 be reserved for the keeper of the game state.", 
            "title": "AR: Actor"
        }, 
        {
            "location": "/components/#an-action", 
            "text": "Size: 4 bytes  Acceptable Values: 0x00000000 - 0xFFFFFFFF   An Action is a game event taken by an Actor. Like the definition of an Actor, Actions are left intentionally vague. They\ncan communicate game state (though this is discouraged) or game actions.", 
            "title": "AN: Action"
        }, 
        {
            "location": "/components/#ac1-ac2-action-condition-1-and-2", 
            "text": "Size: 4 bytes each  Acceptable Values: 0x00000000 - 0xFFFFFFFF  Optional   Action Conditions act as parameters for Actions. They are used to attach data an Action. Their use is optional. If an \nAction does not require the use of Conditions, the byte ranges for those conditions should be cleared to 0x00.  If the data associated with an Action would exceed 8 bytes, use an  ActionExt  Message, which sends arbitrary data in\na following  Data  or  DataEnd  Message.", 
            "title": "AC1, AC2: Action Condition 1 and 2"
        }, 
        {
            "location": "/components/#dat-action-data", 
            "text": "Size: User-defined  Acceptable Values: User-defined   Action Data makes up the primary content of a  Data  Message. Its purpose is to communicate data which is too large to\nfit in a standard  Action  Message.", 
            "title": "DAT : Action Data"
        }, 
        {
            "location": "/components/#siz-data-size", 
            "text": "Size: 1 byte  Acceptable Values: 0x00 - 0xFF   Data Size specifies the length, in bytes, of Action Data attached to a  Data  or  DataEnd  Message.", 
            "title": "SIZ: Data Size"
        }, 
        {
            "location": "/components/#pmsg-parent-message", 
            "text": "Size: 4 bytes  Acceptable Values: 0x00000000 - 0xFFFFFFFF   Parent Message is used by  Data / DataEnd  or  Ack  Messages to express the Message ID with which they are associated. A  Data / DataEnd  Message must additionally have a Message ID of its own.", 
            "title": "PMSG: Parent Message"
        }, 
        {
            "location": "/message-types/", 
            "text": "Message Types\n\n\nGGMP provides a number of various \nMessage Types\n for a variety of use cases related to game client and server\n programming. Many of these types are designed to be as flexible as possible. GGMP stands for \nGeneric\n Gameserver \n Messaging Protocol, after all. It's up to you, the game developer to determine what Actor 45 is, what Actions he can \n take, and what to do with all that information. Is it critical that the server receive your data? Use an \nAck\n variant\n of your Message and your client library will ensure it's received. Don't need support for over 4 billion actors? Use \n \nActionShort\n Messages for your game instead. \n\n\nReq-Ack vs. No-Ack\n\n\nMessage Types ranging from 0x00 to 0xEF have both Req-Ack and No-Ack variants. For the sake of conciseness and brevity, only\ntheir No-Ack variants are listed here. However, since Req-Ack vs. No-Ack doesn't change the structure of a message, converting\nbetween them is easy: Simply increment the Header by 0x01, and you have a Req-Ack version of that message. For example, the \nHeader value for \nAction, No-Ack\n is 0x00. The corresponding Header for \nAction, Req-Ack\n is 0x01. \n\n\nIn this documentation, we will explicitly denote \nReq-Ack\n when referring to such a variant. If no variant is specified, \nit can safely be inferred that the Message in question is \nNo-Ack\n.\n\n\n0x00 - 0xEF: Game State Message Types\n\n\nThese Message Types make up the core of communication over GGMP. \n\n\n0x00 - Action\n\n\nThe bread-and-butter message of GGMP, a game Action with Actors and Conditions.\n\n\nBytes\n\n\n\n\n\n\n\n\n19\n\n\n18\n\n\n17\n\n\n16\n\n\n15\n\n\n14\n\n\n13\n\n\n12\n\n\n11\n\n\n10\n\n\n9\n\n\n8\n\n\n7\n\n\n6\n\n\n5\n\n\n4\n\n\n3\n\n\n2\n\n\n1\n\n\n0\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nAR\n\n\nAR\n\n\nAR\n\n\nAN\n\n\nAN\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead \n\n\nClient ID \n\n\nMessage ID \n\n\nActor ID \n\n\nAction ID \n\n\nAction Condition 1 \n\n\nAction Condition 2 \n\n\n\n\n0x02 - ActionShort\n\n\nA micro-sized version of an Action. Ideal for demos, tutorials, and ultra-lightweight games.\n\n\nBytes\n\n\n\n\n\n\n\n\n7\n\n\n6\n\n\n5\n\n\n4\n\n\n3\n\n\n2\n\n\n1\n\n\n0\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nAR\n\n\nAN\n\n\nAC1\n\n\nAC2\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead \n\n\nClient ID \n\n\nMessage ID \n\n\nActor ID \n\n\nAction ID \n\n\nAction Condition 1 \n\n\nAction Condition 2 \n\n\n\n\n0x04 - ActionExtended\n\n\nAn Action which will be followed by additional \nData\n or \nDataEnd\n messages. Identical in structure to \n0x00\n.\n\n\nIf an ActionExtended Message requires only one additional Data Message, that Message should be \n0x12\n \nDataEnd\n. \n0x12\n\nallows the transmission of data, but also indicates to the receiver that no more data attached to this message should be\nexpected. \n\n\nBytes\n\n\n\n\n\n\n\n\n19\n\n\n18\n\n\n17\n\n\n16\n\n\n15\n\n\n14\n\n\n13\n\n\n12\n\n\n11\n\n\n10\n\n\n9\n\n\n8\n\n\n7\n\n\n6\n\n\n5\n\n\n4\n\n\n3\n\n\n2\n\n\n1\n\n\n0\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nAR\n\n\nAR\n\n\nAR\n\n\nAN\n\n\nAN\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC1\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\nAC2\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead \n\n\nClient ID \n\n\nMessage ID \n\n\nActor ID \n\n\nAction ID \n\n\nAction Condition 1 \n\n\nAction Condition 2  \n\n\n\n\n0x0E - Data\n\n\nData attached to an \nActionExtended\n Message. Data Messages should not be sent without a preceding ActionExtended \nMessage. If the transfer of such 'orphaned' data is required, use \n0x10\n - \nRaw Data\n.\n\n\nThe Data message is \nn + 11\n bytes long, where \nn\n = the size of the data attached. Attached data is limited to 255 bytes.\n\n\nBytes\n\n\n\n\n\n\n\n\nn + 10\n\n\nn + 9\n\n\nn + 8\n\n\nn + 7\n\n\nn + 6\n\n\nn + 5\n\n\nn + 4\n\n\nn + 3\n\n\nn + 2\n\n\nn + 1\n\n\nn\n\n\nn-1\n\n\n...\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nPMSG\n\n\nPMSG\n\n\nPMSG\n\n\nSIZ\n\n\nDAT\n\n\nDAT\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead\n\n\nClient ID\n\n\nMessage ID\n\n\nParent Message\n\n\nSize\n\n\nData\n\n\n\n\n0x12 - DataEnd\n\n\nIdentical in structure to \n0x0E\n - \nData\n. However, this Message Type indicates that this is the final Data Message\nattached to its associated Parent Message. Therefore, every \n0x04\n \nActionExtended\n Message should be followed by any \nnumber of \n0x0E\n \nData\n Messages, and exactly one \n0x12\n \nDataEnd\n Message.\n\n\nBytes\n\n\n\n\n\n\n\n\nn + 10\n\n\nn + 9\n\n\nn + 8\n\n\nn + 7\n\n\nn + 6\n\n\nn + 5\n\n\nn + 4\n\n\nn + 3\n\n\nn + 2\n\n\nn + 1\n\n\nn\n\n\nn-1\n\n\n...\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nMID\n\n\nMID\n\n\nMID\n\n\nPMSG\n\n\nPMSG\n\n\nPMSG\n\n\nSIZ\n\n\nDAT\n\n\nDAT\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead\n\n\nClient ID\n\n\nMessage ID\n\n\nParent Message\n\n\nSize\n\n\nData\n\n\n\n\n0xF0 - 0xFF: Protocol State Message Types\n\n\nThese Messages communicate information about the state of the client, server, and connection.\n\n\n0xFF - Ack\n\n\nAcknowledges the receipt of any Message which requires it. PMSG is the Message ID of the Message requiring Ack. Ack \n messages never require further Acks. See \nAck Behavior\n for details on GGMP's Ack behavior.\n\n\nBytes\n\n\n\n\n\n\n\n\n6\n\n\n5\n\n\n4\n\n\n3\n\n\n2\n\n\n1\n\n\n0\n\n\n\n\n\n\n\n\n\n\nHEAD\n\n\nCL\n\n\nCL\n\n\nCL\n\n\nPMSG\n\n\nPMSG\n\n\nPMSG\n\n\n\n\n\n\n\n\nComponents\n\n\n\n\nHead\n\n\nClient ID\n\n\nParent Message", 
            "title": "Message Types"
        }, 
        {
            "location": "/message-types/#message-types", 
            "text": "GGMP provides a number of various  Message Types  for a variety of use cases related to game client and server\n programming. Many of these types are designed to be as flexible as possible. GGMP stands for  Generic  Gameserver \n Messaging Protocol, after all. It's up to you, the game developer to determine what Actor 45 is, what Actions he can \n take, and what to do with all that information. Is it critical that the server receive your data? Use an  Ack  variant\n of your Message and your client library will ensure it's received. Don't need support for over 4 billion actors? Use \n  ActionShort  Messages for your game instead.", 
            "title": "Message Types"
        }, 
        {
            "location": "/message-types/#req-ack-vs-no-ack", 
            "text": "Message Types ranging from 0x00 to 0xEF have both Req-Ack and No-Ack variants. For the sake of conciseness and brevity, only\ntheir No-Ack variants are listed here. However, since Req-Ack vs. No-Ack doesn't change the structure of a message, converting\nbetween them is easy: Simply increment the Header by 0x01, and you have a Req-Ack version of that message. For example, the \nHeader value for  Action, No-Ack  is 0x00. The corresponding Header for  Action, Req-Ack  is 0x01.   In this documentation, we will explicitly denote  Req-Ack  when referring to such a variant. If no variant is specified, \nit can safely be inferred that the Message in question is  No-Ack .", 
            "title": "Req-Ack vs. No-Ack"
        }, 
        {
            "location": "/message-types/#0x00-0xef-game-state-message-types", 
            "text": "These Message Types make up the core of communication over GGMP.", 
            "title": "0x00 - 0xEF: Game State Message Types"
        }, 
        {
            "location": "/message-types/#0x00-action", 
            "text": "The bread-and-butter message of GGMP, a game Action with Actors and Conditions.  Bytes     19  18  17  16  15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0      HEAD  CL  CL  CL  MID  MID  MID  AR  AR  AR  AN  AN  AC1  AC1  AC1  AC1  AC2  AC2  AC2  AC2     Components   Head   Client ID   Message ID   Actor ID   Action ID   Action Condition 1   Action Condition 2", 
            "title": "0x00 - Action"
        }, 
        {
            "location": "/message-types/#0x02-actionshort", 
            "text": "A micro-sized version of an Action. Ideal for demos, tutorials, and ultra-lightweight games.  Bytes     7  6  5  4  3  2  1  0      HEAD  CL  MID  MID  AR  AN  AC1  AC2     Components   Head   Client ID   Message ID   Actor ID   Action ID   Action Condition 1   Action Condition 2", 
            "title": "0x02 - ActionShort"
        }, 
        {
            "location": "/message-types/#0x04-actionextended", 
            "text": "An Action which will be followed by additional  Data  or  DataEnd  messages. Identical in structure to  0x00 .  If an ActionExtended Message requires only one additional Data Message, that Message should be  0x12   DataEnd .  0x12 \nallows the transmission of data, but also indicates to the receiver that no more data attached to this message should be\nexpected.   Bytes     19  18  17  16  15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0      HEAD  CL  CL  CL  MID  MID  MID  AR  AR  AR  AN  AN  AC1  AC1  AC1  AC1  AC2  AC2  AC2  AC2     Components   Head   Client ID   Message ID   Actor ID   Action ID   Action Condition 1   Action Condition 2", 
            "title": "0x04 - ActionExtended"
        }, 
        {
            "location": "/message-types/#0x0e-data", 
            "text": "Data attached to an  ActionExtended  Message. Data Messages should not be sent without a preceding ActionExtended \nMessage. If the transfer of such 'orphaned' data is required, use  0x10  -  Raw Data .  The Data message is  n + 11  bytes long, where  n  = the size of the data attached. Attached data is limited to 255 bytes.  Bytes     n + 10  n + 9  n + 8  n + 7  n + 6  n + 5  n + 4  n + 3  n + 2  n + 1  n  n-1  ...      HEAD  CL  CL  CL  MID  MID  MID  PMSG  PMSG  PMSG  SIZ  DAT  DAT     Components   Head  Client ID  Message ID  Parent Message  Size  Data", 
            "title": "0x0E - Data"
        }, 
        {
            "location": "/message-types/#0x12-dataend", 
            "text": "Identical in structure to  0x0E  -  Data . However, this Message Type indicates that this is the final Data Message\nattached to its associated Parent Message. Therefore, every  0x04   ActionExtended  Message should be followed by any \nnumber of  0x0E   Data  Messages, and exactly one  0x12   DataEnd  Message.  Bytes     n + 10  n + 9  n + 8  n + 7  n + 6  n + 5  n + 4  n + 3  n + 2  n + 1  n  n-1  ...      HEAD  CL  CL  CL  MID  MID  MID  PMSG  PMSG  PMSG  SIZ  DAT  DAT     Components   Head  Client ID  Message ID  Parent Message  Size  Data", 
            "title": "0x12 - DataEnd"
        }, 
        {
            "location": "/message-types/#0xf0-0xff-protocol-state-message-types", 
            "text": "These Messages communicate information about the state of the client, server, and connection.", 
            "title": "0xF0 - 0xFF: Protocol State Message Types"
        }, 
        {
            "location": "/message-types/#0xff-ack", 
            "text": "Acknowledges the receipt of any Message which requires it. PMSG is the Message ID of the Message requiring Ack. Ack \n messages never require further Acks. See  Ack Behavior  for details on GGMP's Ack behavior.  Bytes     6  5  4  3  2  1  0      HEAD  CL  CL  CL  PMSG  PMSG  PMSG     Components   Head  Client ID  Parent Message", 
            "title": "0xFF - Ack"
        }, 
        {
            "location": "/ack-behavior/", 
            "text": "Acknowledgement Behavior\n\n\nThe Ack message is perhaps the most important of the Message Types in GGMP. It is used in situations where a client or \nserver must know that the other end has received their message; e.g., any situation in which the game state risks \nbecoming desynchronized between the two parties. Consider the following example.\n\n\n*Note: All discussions in this article assume ReqAck variants when discussing a \nMessageType\n. \n\n\nHEAD 0x05   Action Extended Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x003F Move Along Vector\nAC1  0x0000 None\n...\n\nHEAD 0x13   Data End Req Ack\n...\nDAT  0xF3.. \nVector Definition\n\n\nEAD 0x05   Action Extended Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x003F Move Along Vector\nAC1  0x0000 None\n...\n\nHEAD 0x13   Data End Req Ack\n...\nDAT  0xF4.. \nNew Vector Definition\n\n\n\n\n\nBoth message sets require acknowledgment, but to what degree? If the initial \nActionExt\n message is never acknowledged, \ndoes it make sense to send its \nDataEnd\n message? Additionally, what happens if one message pair gets received before\nthe other? \n\n\nNow consider this example\n\n\nHEAD 0x01   Action Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x0030 Move to Position\nAC1  0xFD07 \nPosition Definition\n\nAC2  0xE9C0 \nPosition Definition\n\n...\n\nHEAD 0x01   Action Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x0030 Move to Position\nAC1  0xFD1F \nNew Position Definition\n\nAC2  0xEA06 \nNew Position Definition\n\n...\n\n\n\n\n\nIn this case, once again, both messages require acknowledgement. However, in this case, what happens if only the first\nmessage is dropped? Only the second?\n\n\nAll of these questions can be handled with knowledge of the implementation, but GGMP is intended to be implementation \nagnostic. Even though the first example is communicating events, there are many valid and appealing reasons to\nchoose the second example, which communicates state. \n\n\nIn the first example, it is critical that \nboth\n sets of messages get received, and ideally, in order. Even though \nvector addition is commutative, one set of movements may trace the player model through a nonsensical path. In the\nsecond example, it might be critical that only the most recent movement get acknowledged\n1\n.\n\n\nGGMP defines only one rule for acknowledgment of messages.\n\n\nMandatory Ack Behavior\n\n\nSenders implementing GGMP must respond to every \nReqAck\n message with an \nAck\n message. Receivers implementing GGMP\nmust resend unacknowledged messages if they have not received an \nAck\n for that message within #TIMEOUT\n\n2\n ms. If the message remains unacknowledged, this process should be repeated 2 \nmore times, each time incrementing #TIMEOUT by an additional #TIMEOUT ms. \n\n\n#TIMEOUT = 30ms\nSender                      Receiver\n|                                  |\n| --- MID 0x0021, ReqAck --------\n |   \n| ...30ms...                       |\n| --- MID 0x0021, ReqAck --------\n |\n| ...60ms...                       |\n| --- MID 0x0021, ReqAck --------\n |\n| ...90ms...                       |\n| --- MID 0x0021, ReqAck --------\n |\n|\n\n\n\n\nThe Protocol does not explicitly define behavior beyond this point. However, the GGMP Libraries provided by the GGMP \nContributors will offer some advanced functionality.\n\n\nFootnotes\n\n\n\n\nThere are many valid situations where it's also critical that all state-based movement messages get received as well.\n\n\n#TIMEOUT has yet to be defined.", 
            "title": "Ack Behavior"
        }, 
        {
            "location": "/ack-behavior/#acknowledgement-behavior", 
            "text": "The Ack message is perhaps the most important of the Message Types in GGMP. It is used in situations where a client or \nserver must know that the other end has received their message; e.g., any situation in which the game state risks \nbecoming desynchronized between the two parties. Consider the following example.  *Note: All discussions in this article assume ReqAck variants when discussing a  MessageType .   HEAD 0x05   Action Extended Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x003F Move Along Vector\nAC1  0x0000 None\n...\n\nHEAD 0x13   Data End Req Ack\n...\nDAT  0xF3..  Vector Definition \n\nEAD 0x05   Action Extended Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x003F Move Along Vector\nAC1  0x0000 None\n...\n\nHEAD 0x13   Data End Req Ack\n...\nDAT  0xF4..  New Vector Definition   Both message sets require acknowledgment, but to what degree? If the initial  ActionExt  message is never acknowledged, \ndoes it make sense to send its  DataEnd  message? Additionally, what happens if one message pair gets received before\nthe other?   Now consider this example  HEAD 0x01   Action Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x0030 Move to Position\nAC1  0xFD07  Position Definition \nAC2  0xE9C0  Position Definition \n...\n\nHEAD 0x01   Action Req Ack\n...\nAR   0x0001 Player 1 Entity Model\nAN   0x0030 Move to Position\nAC1  0xFD1F  New Position Definition \nAC2  0xEA06  New Position Definition \n...  In this case, once again, both messages require acknowledgement. However, in this case, what happens if only the first\nmessage is dropped? Only the second?  All of these questions can be handled with knowledge of the implementation, but GGMP is intended to be implementation \nagnostic. Even though the first example is communicating events, there are many valid and appealing reasons to\nchoose the second example, which communicates state.   In the first example, it is critical that  both  sets of messages get received, and ideally, in order. Even though \nvector addition is commutative, one set of movements may trace the player model through a nonsensical path. In the\nsecond example, it might be critical that only the most recent movement get acknowledged 1 .  GGMP defines only one rule for acknowledgment of messages.", 
            "title": "Acknowledgement Behavior"
        }, 
        {
            "location": "/ack-behavior/#mandatory-ack-behavior", 
            "text": "Senders implementing GGMP must respond to every  ReqAck  message with an  Ack  message. Receivers implementing GGMP\nmust resend unacknowledged messages if they have not received an  Ack  for that message within #TIMEOUT 2  ms. If the message remains unacknowledged, this process should be repeated 2 \nmore times, each time incrementing #TIMEOUT by an additional #TIMEOUT ms.   #TIMEOUT = 30ms\nSender                      Receiver\n|                                  |\n| --- MID 0x0021, ReqAck --------  |   \n| ...30ms...                       |\n| --- MID 0x0021, ReqAck --------  |\n| ...60ms...                       |\n| --- MID 0x0021, ReqAck --------  |\n| ...90ms...                       |\n| --- MID 0x0021, ReqAck --------  |\n|  The Protocol does not explicitly define behavior beyond this point. However, the GGMP Libraries provided by the GGMP \nContributors will offer some advanced functionality.", 
            "title": "Mandatory Ack Behavior"
        }, 
        {
            "location": "/ack-behavior/#footnotes", 
            "text": "There are many valid situations where it's also critical that all state-based movement messages get received as well.  #TIMEOUT has yet to be defined.", 
            "title": "Footnotes"
        }, 
        {
            "location": "/techspecs/", 
            "text": "Technical Specifications\n\n\nGGMP uses UDP port 12358.", 
            "title": "Technical Specifications"
        }, 
        {
            "location": "/techspecs/#technical-specifications", 
            "text": "GGMP uses UDP port 12358.", 
            "title": "Technical Specifications"
        }
    ]
}